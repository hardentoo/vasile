#!/usr/bin/env bash

# import gentoo functions

source /lib/gentoo/functions.sh

# generic variables

export local releasename="redcore"
export local releasetarget="desktop"
export local releaseversion="1"

# kernel version && name from inside core squashfs (we need to know this, to generate a matching kernel/live initramfs)

export local kernelver="4.9.30-"$releasename""

# core squahfs name and md5 checksum file

export local chrootx64=""$releasename"_"$releaseversion"_core_x64.squashfs"
export local chrootx64md5=""$chrootx64".md5"

# overlay mount variables

export local rodir="rodir"
export local rwdir="rwdir"
export local workdir="workdir" # only needed for overlayfs on kernel greather than 3.18
export local overlaydir="overlaydir"

# build variables and commands to run inside core squashfs when building packages

export local chrootuser="root"
export local chroottarget="${@:2}"
export local chrootbuildtarget="emerge -kav "$chroottarget""
export local chrootsrcmode="vasile --srcmode"

# iso variables and commands to run inside core squahfs when making iso image

export local isouser="root"
export local isomainarch="x86_64"
export local isobinmode="vasile --binmode"
export local isodkms="vasile --dkms"
export local isokernelname="kernel-genkernel-"$isomainarch"-"$kernelver""
export local isoramfsname="initramfs-genkernel-"$isomainarch"-"$kernelver""
export local isoramfscmd="dracut -N -a dmsquash-live -a pollcdrom --force"
export local isochainloadcmd="grub2-mkimage -d /usr/lib64/grub/i386-pc -o core.img -O i386-pc biosdisk part_msdos fat"
export local isoeficmd="grub2-mkimage -d /usr/lib64/grub/x86_64-efi -o bootx64.efi -O x86_64-efi ext2 fat udf btrfs ntfs reiserfs xfs hfsplus lvm ata part_msdos part_gpt part_apple bsd search_fs_uuid normal chain iso9660 configfile help loadenv reboot cat search memdisk tar boot linux chain"

# iso image layout variables

export local bootloaderfetchpath="/tmp/bootcore"
export local bootloaderconfigs=""$bootloaderfetchpath"/cdroot/boot"
export local isorootdir=""$releasename"-"$releasetarget"-"$releaseversion"-"$isomainarch""
export local isogrubdir=""$isorootdir"/boot/grub"
export local isoefidir=""$isorootdir"/efi/boot"
export local isorsynctarget=""$isorootdir"/rootfs"
export local isorsyncsource="/tmp/"$isorootdir""
export local isocdrootdir=""$isorootdir"/CDroot"
export local isorealfsdir=""$isocdrootdir"/LiveOS"
export local isosquashfsdir=""$isorootdir"/LiveOS"

# modechange variables

export local portagedir="/usr/portage"
export local confdir="/etc/portage"
export local gitdir="/opt/redcore-build/conf/intel/portage"
export local clonedir="/opt/redcore-build"

# generic functions (used for both build && iso creation)

kernelconfig () {
	# check if the host kernel has needed modules for vasile to work properly...fail to start if it doesn't
	if [[ $(zgrep 'CONFIG_OVERLAY_FS=' /proc/config.gz) && $(zgrep "CONFIG_SQUASHFS=" /proc/config.gz) &&  $(zgrep "CONFIG_BLK_DEV_LOOP=" /proc/config.gz) ]] ; then
		einfo "Kernel configuration seems OK, moving on"
		sleep 1
	else
		eerror "Vasile needs OVERLAYFS && SQUASHFS && LOOP DEVICES to work"
		eerror "Please rebuild the kernel with those activated to use it"
		exit 1
	fi
}

checkroot () {
	# check for root privileges, needed for mount && chroot...fail to start if not root
	if [[ "$(whoami)" != root ]] ; then
		eerror "You're not root?...No cookies for you, go away !!!"
		exit 1
	fi
}

checkiflive () {
	# check if running in live mode...fail to start if so
	if [[ -L /dev/mapper/live-base ]] ; then
		eerror "Running in Live mode is unsupported"
		exit 1
	fi
}

chrootchecksum () {
	# check if core squashfs and md5 checksum file exists, verify core squashfs integrity against md5 checksum file
	# fail to start if core squashfs or md5 checksum file doesn't exist, or if core squashfs fails md5 verification
	while : true ; do
		if [[ -f "$chrootx64" && -f "$chrootx64md5" ]] ; then
			einfo "Squashed chroot && Checksum file found"
			if [[ "$(md5sum -c "$chrootx64md5")" ]] ; then
				einfo "Squashed chroot checksum passed"
				sleep 1
				break
			else
				eerror "Squashed chroot checksum failed"
				exit 1
			fi
		else
			eerror "Squashed chroot || Checksum file not found"
			exit 1
		fi
	done
}

dkmsmod () {
	checkroot
	# build and install any 3rd party kernel modules using DKMS
	if [[ -x $(which dkms) ]] ; then
		for i in $(dkms status | cut -d " " -f1,2 | sed -e 's/,//g' | sed -e 's/ /\//g' | sed -e 's/://g') ; do
			dkms install $i
		done
	fi
}

# build functions

chrootprepare () {
	# always start from fresh overlay mount path, if previous exists, remove it and start over
	while : true ; do
		if [[ ! -d "$rodir" && ! -d "$rwdir" && ! -d "$workdir" && ! -d "$overlaydir" ]] ; then
			for i in "$rodir" "$rwdir" "$workdir" "$overlaydir" ; do
				mkdir "$i"
			done
			chrootstart
			break
		elif [[ -d "$rodir" && -d "$rwdir" && -d "$workdir" && -d "$overlaydir" ]] ; then
			chrootstop
			for i in "$rodir" "$rwdir" "$workdir" "$overlaydir" ; do
				rm -rf "$i"
			done
			continue
		fi
	done

}

chrootstop () {
	# umount core squashfs overlay mount
	umount -l "$overlaydir"/proc > /dev/null 2>&1
	umount -l "$overlaydir"/sys > /dev/null 2>&1
	umount -l "$overlaydir"/dev/pts > /dev/null 2>&1
	umount -l "$overlaydir"/dev/shm > /dev/null 2>&1
	umount -l "$overlaydir"/dev > /dev/null 2>&1
	umount -l "$overlaydir"/tmp > /dev/null 2>&1
	umount -l "$overlaydir"/usr/portage/packages > /dev/null 2>&1
	umount -l "$overlaydir"/usr/portage/distfiles > /dev/null 2>&1
	umount -l "$overlaydir" > /dev/null 2>&1
	umount -l "$rodir" > /dev/null 2>&1
}

chrootstart () {
	# mount core squashfs in overlay
	mount -t squashfs "$chrootx64" "$rodir"
	mount -t overlay -o lowerdir="$rodir",upperdir="$rwdir",workdir="$workdir" overlay "$overlaydir"
	mount -o bind packages "$overlaydir"/usr/portage/packages
	mount -o bind distfiles "$overlaydir"/usr/portage/distfiles
	mount -t proc proc "$overlaydir"/proc
	mount -t sysfs sysfs "$overlaydir"/sys
	mount -t devtmpfs -o relatime,size=3055348k,nr_inodes=763837,mode=755 none "$overlaydir"/dev
	mount -t devpts -o nosuid,noexec,relatime,gid=5,mode=620 none "$overlaydir"/dev/pts
	mount -t tmpfs -o nosuid,nodev none "$overlaydir"/dev/shm
	mount -t tmpfs -o nosuid,nodev,noexec none  "$overlaydir"/tmp
}

chrootdevtree () {
	# inject portage tree, redcore overlay && redcore buildsystem (portage config)
	chroot "$overlaydir" su - "$chrootuser" -c "$chrootsrcmode"
}

chrootbuild () {
	# build and install package(s) given as argument...if is already built, install it
	einfo "All systems are go!"
	sleep 1
	chroot "$overlaydir" su - "$chrootuser" -c "$chrootbuildtarget"
}

chrootx64 () {
	# land into a chroot env into overlay mounted core squashfs and make build adjustments, if needed
	einfo "DROPPING YOU TO A ROOT SHELL INTO BUILD ENVIRONMENT"
	einfo "FIX FAILURES && ADJUST PORTAGE CONFIGURATION FILES"
	einfo "TEST USEFLAGS && KEYWORDS && MASKS IF REQUIRED"
	einfo "IN THE END : DO NOT FORGET TO COMMIT YOUR CHANGES"
	chroot "$overlaydir" su - "$chrootuser"
}

makepkg () {
	checkroot
	chrootchecksum
	chrootprepare
	chrootdevtree
	chrootbuild
	chrootx64
	chrootstop
}

# iso functions

isostart () {
	# mount iso image core
	mount -o bind packages "$isorsynctarget"/usr/portage/packages
	mount -t proc proc "$isorsynctarget"/proc
	mount -t sysfs sysfs "$isorsynctarget"/sys
	mount -t devtmpfs -o relatime,size=3055348k,nr_inodes=763837,mode=755 none "$isorsynctarget"/dev
	mount -t devpts -o nosuid,noexec,relatime,gid=5,mode=620 none "$isorsynctarget"/dev/pts
	mount -t tmpfs -o nosuid,nodev none "$isorsynctarget"/dev/shm
	mount -t tmpfs -o nosuid,nodev,noexec none  "$isorsynctarget"/tmp
}

isostop () {
	# umount iso image core
	umount -l "$isorsynctarget"/proc > /dev/null 2>&1
	umount -l "$isorsynctarget"/sys > /dev/null 2>&1
	umount -l "$isorsynctarget"/dev/pts > /dev/null 2>&1
	umount -l "$isorsynctarget"/dev/shm > /dev/null 2>&1
	umount -l "$isorsynctarget"/dev > /dev/null 2>&1
	umount -l "$isorsynctarget"/tmp > /dev/null 2>&1
	umount -l "$isorsynctarget"/usr/portage/packages > /dev/null 2>&1
}

isousertree () {
	# inject portage tree, redcore overlay && redcore buildsystem (portage config)
	chroot "$isorsynctarget" su - "$isouser" -c "$isobinmode"
}

isoramfs () {
	# generate iso initramfs with required modules for live boot
	chroot "$isorsynctarget" su - "$isouser" -c "$isoramfscmd"
}

isoefiimg () {
	# generate efi bootloader
	chroot "$isorsynctarget" su - "$isouser" -c "$isoeficmd"
}

isochainloader () {
	# generate syslinux -> grub chainloader for unetbootin compatibility
	chroot "$isorsynctarget" su - "$isouser" -c "$isochainloadcmd"
}

isoservices () {
	# enable live iso image system services (runlevel : default)
	for service in dbus connman avahi-daemon syslog-ng cupsd cronie cgmanager consolekit alsasound bluetooth xdm ; do
		chroot "$isorsynctarget" su - "$isouser" -c "rc-update add "$service" default"
	done
}

isomodules () {
	# build and install any 3rd party kernel modules using DKMS (virtualbox-guest in our case)
	chroot "$isorsynctarget" su - "$isouser" -c "$isodkms"
}

isochroot () {
	# land into a chroot env into iso image core and make adjustments, if needed
	einfo "DROPPING YOU TO A ROOT SHELL INTO ISO ENVIRONMENT"
	einfo "INSTALL APPS & TARGETS & DES YOU WANT INSIDE ISO"
	einfo "EXIT WHEN YOU'RE DONE AND I'LL CREATE THE IMAGE"
	chroot "$isorsynctarget" su - "$isouser"
}

prepareiso () {
	# prepare iso image layout
	mkdir -p "$isorsynctarget"
	dd if=/dev/zero of=""$isorsynctarget".img" bs=50M count=400
	mkfs.ext4 ""$isorsynctarget".img"
	mkdir -p "$isorsyncsource"
	mkdir -p "$isocdrootdir"
	mkdir -p "$isosquashfsdir"
	mkdir -p "$isorealfsdir"
	mkdir -p "$isogrubdir"
	mkdir -p "$isoefidir"
	# mount core squashfs and rsync it's contents into core iso image
	mount -t squashfs "$chrootx64" "$isorsyncsource"
	mount -t ext4 ""$isorsynctarget".img" "$isorsynctarget"
	rsync -aHAXr --progress "$isorsyncsource/" "$isorsynctarget/"
	# copy the kernel for live boot
	cp -avx ""$isorsynctarget"/boot/"$isokernelname"" ""$isorootdir"/boot/vmlinuz"
	# generate and copy initramfs for live boot
	isostart
	isoramfs
	isostop
	mv ""$isorsynctarget"/boot/"$isoramfsname"" ""$isorootdir"/boot/initrd"
	# generate and copy efi bootloader for live boot
	isostart
	isoefiimg
	isostop
	mv ""$isorsynctarget"/root/bootx64.efi" "$isoefidir"
	chmod 755 ""$isoefidir"/bootx64.efi"
	# generate and copy syslinux -> grub chainloader for unetbootin compatibility
	isostart
	isochainloader
	isostop
	mv ""$isorsynctarget"/root/core.img" "$isogrubdir"
	cp -avx ""$isorsynctarget"/usr/lib64/grub/i386-pc/lnxboot.img" "$isogrubdir"
	# land into a chroot env into live environment to make adjustments, if needed
	isostart
	isousertree
	isochroot
	isostop
	# build and install any 3rd party kernel modules using DKMS (virtualbox-guest in our case)
	isostart
	isomodules
	isostop
	# enable live iso image system services
	isostart
	isoservices
	isostop
	umount -l "$isorsynctarget" > /dev/null 2>&1
	# move "real" live filesystem into right place
	mv ""$isorsynctarget".img"  "$isorealfsdir"
	# compress "fake" live filesystem
	mksquashfs "$isocdrootdir" ""$isorootdir"/squashfs.img" -b 1048576 -comp xz -Xdict-size 100%
	mv ""$isorootdir/"squashfs.img" "$isosquashfsdir"
	# dracut requires "real" ext4 live filesystem to be placed 
	# into a "fake" squashfs live filesystem as bellow :
	# /cdroot/LiveOS/squashfs.img/LiveOS/rootfs.img 
	# squashfs.img is the "fake" squashfs live filesystem
	# rootfs.img is the "real" ext4 live filesystem
}

bootloaderiso () {
	# get grub2 live boot configs and place them into right place
	git clone https://gitlab.com/"$releasename"/boot-core.git "$bootloaderfetchpath"
	cp -avx "$bootloaderconfigs" "$isorootdir"
}

cleanupiso () {
	# cleanup temporary files used during iso image layout preparation
	umount "$isorsyncsource"
	rm -rf "$isorsynctarget"
	rm -rf "$isorsyncsource"
	rm -rf "$isocdrootdir"
	rm -rf "$bootloaderfetchpath"
}

makeisoimg () {
	# create iso image
	grub2-mkrescue -o ""$releasename"-"$releasetarget"-"$releaseversion"-"$isomainarch".iso" "$isorootdir"
}

makeiso () {
	checkroot
	chrootchecksum
	prepareiso
	bootloaderiso
	cleanupiso
	makeisoimg
}

# modechange functions

removeportagetree() {
	# remove portage tree, but leave packages and distfiles directories intact
	if [ -d ""$portagedir"/.git" ] ; then
		einfo "Removing gentoo portage tree"
		find "$portagedir" -mindepth 1 -name "packages" -prune -o -name "distfiles" -prune -o -exec rm -rf {} \; > /dev/null 2>&1
	fi
}

removeoverlays() {
	# remove redcore overlay
	einfo "Removing "$releasename"-"$releasetarget" overlay"
	layman -d "$releasename"-"$releasetarget" > /dev/null 2>&1
}

removeportageconfig() {
	# remove redcore buildsystem (portage configuration)
	einfo "Removing "$releasename"-"$releasetarget" buildsystem"
	rm ""$confdir"/make.conf" > /dev/null 2>&1
	rm ""$confdir"/make.profile" > /dev/null 2>&1
	rm "$confdir" > /dev/null 2>&1
	rm -rf "$clonedir" > /dev/null 2>&1
}

resetmode () {
	checkroot
	removeportagetree
	removeoverlays
	removeportageconfig
}

fetchportageconfig() {
	# fetch redcore buildsystem (portage configuration)
	pushd /opt > /dev/null 2>&1
	einfo "Injecting "$releasename"-"$releasetarget" buildsystem"
	git clone https://gitlab.com/redcore/redcore-build.git
	popd > /dev/null 2>&1
}

fetchfullportagetree() {
	# fetch full portage tree
	if [[ ! -d "$portagedir"/.git ]] ; then
		einfo "Injecting mixedmode/srcmode (full) gentoo portage tree"
		cd "$portagedir" && git init > /dev/null 2>&1
		git remote add origin https://gitlab.com/redcore/portage.git
		git pull --depth=1 origin master
		git branch -u origin/master master
		rm -rf ""$portagedir"/profiles/updates"
	fi
}

fetchminimalportagetree() {
	# fetch minimal portage tree
	# in binmode we don't want the whole tree of gentoo ebuilds
	# but we need portage profiles portage metadata && portage eclasses
	# so make a sparse-checkout, to fetch only what we need
	if [[ ! -d "$portagedir"/.git ]] ; then
		einfo "Injecting binmode (minimal) gentoo portage tree"
		cd "$portagedir" && git init > /dev/null 2>&1
		git remote add origin https://gitlab.com/redcore/portage.git
		git config core.sparsecheckout true
		echo "profiles/*" >> .git/info/sparse-checkout
		echo "metadata/*" >> .git/info/sparse-checkout
		echo "eclass/*" >> .git/info/sparse-checkout
		echo ".gitignore" >> .git/info/sparse-checkout
		git pull --depth=1 origin master
		git branch -u origin/master master
		rm -rf ""$portagedir"/profiles/updates"
	fi
}

fetchoverlays () {
	# fetch redcore overlay
	einfo "Injecting "$releasename"-"$releasetarget" overlay"
	layman -f -a "$releasename"-"$releasetarget" -o https://gitlab.com/"$releasename"/"$releasename"-"$releasetarget"/raw/master/overlay.xml
}

setbinmodeconfig() {
	# set make.conf to binmode, portage will always use binary packages from binhost
	ln -sf "$gitdir" "$confdir"
	ln -sf "$confdir"/make.conf.amd64-binmode "$confdir"/make.conf
	eselect profile set 1
	env-update
	. /etc/profile
}

setmixedmodeconfig() {
	# set make.conf to mixedmode, portage will prefer binary packages over ebuilds
	# but will use ebuilds if they are newer than binary packages from binhost
	# or if the binary package is not available in binhost
	ln -sf "$gitdir" "$confdir"
	ln -sf "$confdir"/make.conf.amd64-mixedmode "$confdir"/make.conf
	eselect profile set 1
	env-update
	. /etc/profile
}

setsrcmodeconfig () {
	# set make.conf to srcmode, portage will always use ebuilds
	ln -sf "$gitdir" "$confdir"
	ln -sf "$confdir"/make.conf.amd64-srcmode "$confdir"/make.conf
	eselect profile set 1
	env-update
	. /etc/profile
}

binmode() {
	resetmode
	fetchminimalportagetree
	fetchoverlays
	fetchportageconfig
	setbinmodeconfig
}

mixedmode() {
	resetmode
	fetchfullportagetree
	fetchoverlays
	fetchportageconfig
	setmixedmodeconfig
}

srcmode() {
	resetmode
	fetchfullportagetree
	fetchoverlays
	fetchportageconfig
	setsrcmodeconfig
}

# help menu color variables

export local colorstart="\e[1;49;34m"
export local colorstop="\e[0m"

# help menu function

showhelp () {

echo -e "\
"$colorstart"SYNOPSIS"$colorstop"
	"$colorstart"vasile --option"$colorstop" ["$colorstart"arguments"$colorstop"]
	"$colorstart"vasile --help"$colorstop"

"$colorstart"DESCRIPTION"$colorstop"

	Vasile is an acronym for ** Versatile Advanced Script for Iso and Latest Enchantments **

"$colorstart"OPTIONS"$colorstop"
	"$colorstart"--makepkg"$colorstop" ["$colorstart"package(s)"$colorstop"]
		This option will allow you to build a package or multiple packages in an overlayfs mounted squashfs chroot jail.

		It must be run in the folder where the squashfs chroot jail resides, or else it will fail to mount the squahfs chroot jail and build the package(s).

		The squashfs chroot jail and the md5sum checksum file are hardcored into "$colorstart"libvasile"$colorstop", but you may want to change them to suit your needs.

		You MUST provide package(s) to build as arguments, or else vasile will only mount the chroot jail

		Examples :
			"$colorstart"vasile --makepkg wine"$colorstop"
			"$colorstart"vasile --makepkg wine playonlinux q4wine"$colorstop"

		If the package(s) is/are already built, it will not build it/them again (unless newer version(s) is/are available), but install it/them into squahfs chroot jail

		If the package(s) you want to build depends on any already built package(s) it will make use of it/them to satisfy the required dependencies.

	"$colorstart"--makeiso"$colorstop"
		This option will allow you to build a live iso image based on the squashfs chroot jail.

		It must be run in the folder where the squashfs chroot jail resides, or else it will fail to rsync the contents of it and build the iso image.

		It is not fully automatic, it will only rsync the contents of the squashfs chroot jail, chroot into it, and let you install packages you want into the iso image.
		There are some predefined package sets available in "$colorstart"/etc/portage/sets"$colorstop". Adjust them to suit your needs.

		It will ALLWAYS use package(s) built with "$colorstart"--makepkg"$colorstop" option. When you are happy with package selection, just exit the chroot environment and
		the live filesystem will be compressed, live services will be autoenabled, live bootloader autoconfigured and in the end live iso image will be built. You will find
		a list of predefined live services list hardcoded into "$colorstart"libvasile"$colorstop". Adjust it to suit your needs.

	"$colorstart"--resetmode"$colorstop"
		This option will allow you to reset the system state. It will remove whole portage tree, overlays and portage configuration files and reset the system profile. Usually
		you will never want to call this option directly, unless you really really really know what are you doing. It is called automatically when switching to other states.

		!!! WARNING !!! : Never never never leave the system in this state. You will no longer be able to install/remove/upgrade any packages untill you set the system profile,
		get the portage tree, overlays and configure portage by hand. Or, you can always activate one of the three other supported system states.

	"$colorstart"--binmode"$colorstop"
		This option will allow you to change the system state to binmode. In this state portage will allways use only binary packages from the binhost. It will fetch a minimal
		portage tree without any ebuilds in it, but only with portage profiles, metadata and eclass. It will also fetch overlay and portage configuration files, and will adjust
		"$colorstart"make.conf"$colorstop" for binary only usage. This system state is for those who just meet with the power of Gentoo.

		!!! WARNING !!! : Never never never modify or create any file in "$colorstart"/etc/portage/"$colorstop" in this state.

	"$colorstart"--mixedmode"$colorstop"
		This option will allow you to change the system state to mixedmode. In this state portage will prefer binary packages from the binhost over ebuilds from the portage tree.
		It will fetch the full portage tree, the overlay and portage configuration files, and adjust "$colorstart"make.conf"$colorstop" for binary/ebuild usage. Usually you will find this system state
		useful if you want to install a package not available in the binhost, you want to upgrade a package to a newer version from portage tree or if you wanna rebuild a package
		with your own useflags.

		!!! WARNING !!! : Never never never modify any file in "$colorstart"/etc/portage/"$colorstop" in this state. If you want to adjust useflags or keywords for a package, you can create a new file
		e.g.: "$colorstart"100-my.package.use"$colorstop" in "$colorstart"/etc/portage/package.use/"$colorstop" or "$colorstart"100-my.package.keywords"$colorstop" in "$colorstart"/etc/portage/package.keywords/"$colorstop".

	"$colorstart"--srcmode"$colorstop"
		This option will allow you to change the system state to srcmode. In more clear terms, it will transform your Kogaion/Argent/Redcore system into pure Gentoo. Binary packages
		from the binhost will be ignored, and you will only install packages building from portage tree using emerge. It will fetch the full portage tree, the overlay and portage
		configuration files and adjust "$colorstart"make.conf"$colorstop" for ebuild only usage.

		In this system state you can modify whatever you want in "$colorstart"/etc/portage/"$colorstop". You can adjust useflags, keywords, masks, build environment and rebuild the whole system to suit you.
		You have the full power of Gentoo available only one command away!

		!!! WARNING !!! : Only use this system state if you have a strong knowledge of Gentoo tools e.g.: "$colorstart"emerge, equery, layman, eix, qlist, useflags, keywords, masks"$colorstop".	"
exit 0
}
